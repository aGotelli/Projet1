#!/usr/bin/env python

# modules
# ROS stuff and multithreading
import rospy
import rosbag
import sys
import yaml
from pyqtgraph.Qt import QtGui, QtCore
import numpy as np
import pyqtgraph as pg
from tf.transformations import euler_from_quaternion




if __name__ == '__main__':

    rospy.init_node('plotting')

#################################~  COLLECTING DATA ~###################################

    #   Load from yaml file the parameters
    with file( sys.argv[1] + '.yaml' ) as setting:
        parameters = yaml.load( setting )

    #   Obatin world parameters
    xSpacing = parameters['sensor']['x_spacing']
    ySpacing = parameters['sensor']['y_spacing']
    lineThickness = parameters['sensor']['line_thickness']

    #   Obtain estimator setting
    sigmaTuning = parameters['estimator']['sigma_tuning']
    threshold  = parameters['estimator']['threshold']

    #   Open the required bag file
    bag = rosbag.Bag( sys.argv[1] + '.bag' )

    #   Obatin the real path that the robot has followed
    x_real = []
    y_real = []
    sim_time = []
    theta_real = []
    for topic, robot, t in bag.read_messages(topics=['/RobotPosture']):
        x_real.append( robot.position.x )
        y_real.append( robot.position.y )
        orientation_q = robot.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_real.append( yaw )
        sim_time.append( t.to_sec() )


    #   Obtain an estimation of the path odometry based
    x_odom = []
    y_odom = []
    for topic, odom, t in bag.read_messages(topics=['/RobotOdometry']):
        x_odom.append( odom.pose.pose.position.x )
        y_odom.append( odom.pose.pose.position.y )

    #   Obain the path that the estimator has computed
    x_estm = []
    y_estm = []
    theta_estim = []
    for topic, estm, t in bag.read_messages(topics=['/EstimatedPosture']):
        x_estm.append( estm.pose.position.x )
        y_estm.append( estm.pose.position.y )
        orientation_q = estm.pose.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_estim.append( yaw )



    #   Obtain information about the measurements
    x_m = []
    y_m = []
    for topic, meas, t in bag.read_messages(topics=['/Measurements']):
        x_m.append( meas.pose.position.x )
        y_m.append( meas.pose.position.y )

    #   Obtain the Mahalanobis distances
    mh_dist = []
    time_dist = []
    for topic, dist, t in bag.read_messages(topics=['/Mahalanobis']):
        mh_dist.append( dist.data )
        time_dist.append( t.to_sec() )


    #   No need of the bag file anymore
    bag.close()

#################################~  PREPOCESS DATA ~###################################

    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_real ) )
    i = 0
    while (i<nbSamples) and (x_real[i]-x_real[i+1]==0) and (y_real[i]-y_real[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1
    while (i> -nbSamples) and (x_real[i]-x_real[i-1]==0) and (y_real[i]-y_real[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts).
    del x_real[0: startIndex]
    del y_real[0: startIndex]
    del sim_time[0: startIndex]
    del theta_real[0: startIndex]
    del x_real[stopIndex: -1]
    del y_real[stopIndex: -1]
    del sim_time[stopIndex: -1]
    del theta_real[stopIndex: -1]

    #   Normalize the seconds counters
    sim_time = np.asarray(sim_time)
    sim_time = sim_time - sim_time[0]

    time_dist = np.asarray(time_dist)
    time_dist = time_dist - time_dist[0]





    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_estm ) )
    i = 0
    while (i<nbSamples) and (x_estm[i]-x_estm[i+1]==0) and (y_estm[i]-y_estm[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1

    while (i> -nbSamples) and (x_estm[i]-x_estm[i-1]==0) and (y_estm[i]-y_estm[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts).
    del x_estm[0: startIndex]
    del y_estm[0: startIndex]
    del theta_estim[0: startIndex]
    del x_estm[stopIndex: -1]
    del y_estm[stopIndex: -1]
    del theta_estim[stopIndex: -1]



    x_err = np.asarray( x_real ) - np.asarray( x_estm )
    y_err = np.asarray( y_real ) - np.asarray( y_estm )
    theta_err = np.asarray( theta_real ) - np.asarray( theta_estim )


#################################~  PLOTTING DATA ~###################################

    #   Start the console
    app = QtGui.QApplication([])

    #   Create the first window with paths and distances
    win1 = pg.GraphicsWindow(title="Trajectories, measurements and distances")
    win1.resize(1000,600)
    win1.setWindowTitle('Trajectories, measurements and distances')

    #   Enable antialiasing for prettier plots
    pg.setConfigOptions(antialias=True)

    #   Create first plot containing the trajectories of robot, odometry
    #   and estimator
    p1 = win1.addPlot(title="Trajectories")
    p1.addLegend()
    p1.plot(x_real, y_real, pen=(255,0,0), name="Real path")
    p1.plot(x_odom, y_odom, pen=(0,255,0), name="Odometry path")
    p1.plot(x_estm, y_estm, pen=(0,0,255), name="Estimated path")
    p1.plot(x_m, y_m, pen=None, symbol='o')
    p1.setLabel('left', "Y Axis", units='m')
    p1.setLabel('bottom', "X Axis", units='m')
    p1.showGrid(x=True, y=True)

    #   Create a second plot with the Mahalanobis distances
    p2 = win1.addPlot(title="Mahalanobis distances")
    p2.plot([time_dist[0], time_dist[-1]], [threshold, threshold], pen=(255,0,0), name="Threshold")
    p2.plot(time_dist, mh_dist, pen=None, symbol='o', name="Mahalanobis distance")
    p2.setLabel('left', "x", units='undimensional distances')
    p2.setLabel('bottom', "time", units='s')







    #   Create the second window with the errors
    win2 = pg.GraphicsWindow(title="Errors along x, y and in heading")
    win2.resize(1000,600)
    win2.setWindowTitle('Errors along x, y and in heading')


    p3 = win2.addPlot(title="Error in x")
    p3.plot(sim_time, x_err, pen=(255,0,0), name="Error X")
    p3.setLabel('left', "x", units='m')
    p3.setLabel('bottom', "time", units='s')
    lr_1 = pg.LinearRegionItem([0,5])
    #lr_1.setZValue(-0.01)
    p3.addItem(lr_1)

    p4 = win2.addPlot(title="Zoom on selected region")
    p4.plot(sim_time, x_err, pen=(255,0,0), name="Error X")
    def updatePlot():
        p4.setXRange(*lr_1.getRegion(), padding=0)
    def updateRegion():
        lr_1.setRegion(p4.getViewBox().viewRange()[0])
    lr_1.sigRegionChanged.connect(updatePlot)
    p4.sigXRangeChanged.connect(updateRegion)
    updatePlot()

    win2.nextRow()

    p5 = win2.addPlot(title="Error in y")
    p5.plot(sim_time, y_err, pen=(255,0,0), name="Error Y")
    p5.setLabel('left', "y", units='m')
    p5.setLabel('bottom', "time", units='s')
    lr_2 = pg.LinearRegionItem([0,5])
    #lr.setZValue(-10)
    p5.addItem(lr_2)

    p6 = win2.addPlot(title="Zoom on selected region")
    p6.plot(sim_time, y_err, pen=(255,0,0), name="Error Y")
    def updatePlot():
        p6.setXRange(*lr_2.getRegion(), padding=0)
    def updateRegion():
        lr_2.setRegion(p6.getViewBox().viewRange()[0])
    lr_2.sigRegionChanged.connect(updatePlot)
    p6.sigXRangeChanged.connect(updateRegion)
    updatePlot()

    win2.nextRow()

    p7 = win2.addPlot(title="Error in theta")
    p7.plot(sim_time, theta_err, pen=(255,0,0), name="Error theta")
    p7.setLabel('left', "theta", units='rad')
    p7.setLabel('bottom', "time", units='s')
    lr_3 = pg.LinearRegionItem([5,10])
    #lr.setZValue(-10)
    p7.addItem(lr_3)

    p8 = win2.addPlot(title="Zoom on selected region")
    p8.plot(sim_time, theta_err, pen=(255,0,0), name="Error theta")
    def updatePlot():
        p8.setXRange(*lr_3.getRegion(), padding=0)
    def updateRegion():
        lr_3.setRegion(p8.getViewBox().viewRange()[0])
    lr_3.sigRegionChanged.connect(updatePlot)
    p8.sigXRangeChanged.connect(updateRegion)
    updatePlot()







    QtGui.QApplication.instance().exec_()
