#!/usr/bin/env python

# modules
# ROS stuff and multithreading
import rospy
import rosbag
import sys
import yaml
from pyqtgraph.Qt import QtGui, QtCore
import numpy as np
import pyqtgraph as pg
from tf.transformations import euler_from_quaternion




if __name__ == '__main__':

    rospy.init_node('plotting')

#################################~  COLLECTING DATA ~###################################

    #   Load from yaml file the parameters
    with file( sys.argv[1] + '.yaml' ) as setting:
        parameters = yaml.load( setting )

    #   Obatin world parameters
    xSpacing = parameters['sensor']['x_spacing']
    ySpacing = parameters['sensor']['y_spacing']
    lineThickness = parameters['sensor']['line_thickness']

     #   Obatin robot parameters
    wheelRadius = parameters['robot_2_0']['wheel_radius']
    frontAxle = parameters['robot_2_0']['a']
    wheelRadiusError = parameters['robot_2_0']['wheel_1_error']
    trackGaugeError = parameters['robot_2_0']['track_gauge_error']
    encodersResolution = parameters['robot_2_0']['encoders_resolution']
    xInit = parameters['robot_2_0']['x_init']
    yInit = parameters['robot_2_0']['y_init']
    thetaInit = parameters['robot_2_0']['theta_init']


    #   Obtain estimator setting
    sigmaTuning = parameters['estimator']['sigma_tuning']
    threshold  = parameters['estimator']['threshold']

    #   Open the required bag file
    bag = rosbag.Bag( sys.argv[1] + '.bag' )


    #   Obatin the real path that the robot has followed
    x_real = []
    y_real = []
    theta_real = []
    sim_time = []
    for topic, robot, t in bag.read_messages(topics=['/RobotPosture']):
        x_real.append( robot.position.x )
        y_real.append( robot.position.y )
        orientation_q = robot.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_real.append( yaw )
        sim_time.append( t.to_sec() )


    #   Obtain the path that the estimator has computed
    x_estm = []
    y_estm = []
    theta_estim = []
    cov_x = []
    cov_y = []
    cov_theta = []
    estm_time = []
    for topic, estm, t in bag.read_messages(topics=['/EstimatedPosture']):
        x_estm.append( estm.pose.position.x )
        y_estm.append( estm.pose.position.y )
        orientation_q = estm.pose.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_estim.append( yaw )
        cov_x.append( estm.covariance[6*0 + 0] )
        cov_y.append( estm.covariance[6*1 + 1] )
        cov_theta.append( estm.covariance[6*5 + 5] )
        estm_time.append( t.to_sec() )


    #   Obtain the error in the estimation
    x_err = []
    y_err = []
    theta_err = []
    for topic, error, t in bag.read_messages(topics=['/EstimationError']):
        x_err.append( error.position.x )
        y_err.append( error.position.y )
        orientation_q = error.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion( orientation_list )
        theta_err.append( yaw )


    #   Obtain an estimation of the path odometry based
    x_odom = []
    y_odom = []
    for topic, odom, t in bag.read_messages(topics=['/RobotOdometry']):
        x_odom.append( odom.pose.pose.position.x )
        y_odom.append( odom.pose.pose.position.y )


    #   Obtain information about the measurements
    sx = []
    sy = []
    lines_detected = []
    prev_h = -1000
    prev_v = -1000
    for topic, meas, t in bag.read_messages(topics=['/Measurements']):
        sx.append( meas.pose.position.x )
        sy.append( meas.pose.position.y )

        if meas.line_type.data == 'HORIZONTAL':

            if meas.line_index.data != prev_h:
                pos = [[meas.pose.position.x - xSpacing/2, meas.pose.position.x + xSpacing/2], [meas.line_index.data, meas.line_index.data]]
                lines_detected.append(pos)
                prev_h = meas.line_index.data
        else:
            if meas.line_index.data != prev_v:
                pos = [[meas.line_index.data, meas.line_index.data], [meas.pose.position.y - ySpacing/2, meas.pose.position.y + ySpacing/2]]
                lines_detected.append(pos)
                prev_v = meas.line_index.data


    #   Obtain the Mahalanobis distances
    mh_dist = []
    time_dist = []
    for topic, dist, t in bag.read_messages(topics=['/Mahalanobis']):
        mh_dist.append( dist.data )
        time_dist.append( t.to_sec() )


    #   Obtain the input velocities
    linear = []
    angular = []
    for topic, vel, t in bag.read_messages(topics=['/Velocities']):
        linear.append( vel.linear.x )
        angular.append( vel.angular.z )


    #   No need of the bag file anymore
    bag.close()

    print( len( lines_detected ))

#################################~  PREPOCESS DATA ~###################################

    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_real ) )
    i = 0
    while (i<nbSamples) and (x_real[i]-x_real[i+1]==0) and (y_real[i]-y_real[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1
    while (i> -nbSamples) and (x_real[i]-x_real[i-1]==0) and (y_real[i]-y_real[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts).
    del x_real[0: startIndex]
    del y_real[0: startIndex]
    del theta_real[0: startIndex]
    del sim_time[0: startIndex]

    del x_real[stopIndex: -1]
    del y_real[stopIndex: -1]
    del theta_real[stopIndex: -1]
    del sim_time[stopIndex: -1]

    #   Normalize the seconds counters
    sim_time = np.asarray(sim_time)
    sim_time = sim_time - sim_time[0]



    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_estm ) ) -1
    i = 0
    while (i<nbSamples) and (x_estm[i]-x_estm[i+1]==0) and (y_estm[i]-y_estm[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1

    while (i> -nbSamples) and (x_estm[i]-x_estm[i-1]==0) and (y_estm[i]-y_estm[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts).
    del x_estm[0: startIndex]
    del y_estm[0: startIndex]
    del theta_estim[0: startIndex]
    del cov_x[0: startIndex]
    del cov_y[0: startIndex]
    del cov_theta[0: startIndex]
    del x_err[0: startIndex]
    del y_err[0: startIndex]
    del theta_err[0: startIndex]
    del estm_time[0: startIndex]
    del linear[0: startIndex]
    del angular[0: startIndex]


    del x_estm[stopIndex: -1]
    del y_estm[stopIndex: -1]
    del theta_estim[stopIndex: -1]
    del cov_x[stopIndex: -1]
    del cov_y[stopIndex: -1]
    del cov_theta[stopIndex: -1]
    del x_err[stopIndex: -1]
    del y_err[stopIndex: -1]
    del theta_err[stopIndex: -1]
    del estm_time[stopIndex: -1]
    del linear[stopIndex: -1]
    del angular[stopIndex: -1]

    #   Normalize the seconds counters
    time_dist = np.asarray(time_dist)
    time_dist = time_dist - time_dist[0]

    estm_time = np.asarray(estm_time)
    estm_time = estm_time - estm_time[0]



#################################~  PLOTTING DATA ~###################################


    #   Start the console
    app = QtGui.QApplication([])


    #  Create the fifth window with velocities
#    win5 = pg.GraphicsWindow(title="Velocities")
#    win5.resize(1000,600)
#    win5.setWindowTitle('Velocities')
#
#    p12 = win5.addPlot(title="Linear Velocity")
#    p12.plot( estm_time, linear, pen=(255,0,0), name="linear vel")
#    p12.setLabel('left', "linear vel")
#    p12.setLabel('bottom', "time", units='s')
#
#    win5.nextRow()
#
#    p13 = win5.addPlot(title="Angular Velocity")
#    p13.plot( estm_time, angular, pen=(255,0,0), name="angular vel")
#    p13.setLabel('left', "angular vel")
#    p13.setLabel('bottom', "time", units='s')




    #  Create the fourth window with standard deviations
    win4 = pg.GraphicsWindow(title="Standard deviations of x, y and theta")
    win4.resize(1000,600)
    win4.setWindowTitle('Standard deviations of x, y and theta')

    p9 = win4.addPlot(title="Standard deviation of x")
    p9.plot(estm_time, cov_x, pen=(255,0,0), name="sigma X")
    p9.setLabel('left', "sigma x")
    p9.setLabel('bottom', "time", units='s')

    win4.nextRow()

    p10 = win4.addPlot(title="Standard deviation of y")
    p10.plot(estm_time, cov_y, pen=(255,0,0), name="sigma Y")
    p10.setLabel('left', "sigma y")
    p10.setLabel('bottom', "time", units='s')

    win4.nextRow()

    p11 = win4.addPlot(title="Standard deviation of theta")
    p11.plot(estm_time, cov_theta, pen=(255,0,0), name="sigma Theta")
    p11.setLabel('left', "sigma theta")
    p11.setLabel('bottom', "time", units='s')




#    #   Create the third window with the errors
#    win3 = pg.GraphicsWindow(title="Errors along x, y and in heading")
#    win3.resize(1000,600)
#    win3.setWindowTitle('Errors along x, y and in heading')


#    p3 = win3.addPlot(title="Error in x")
#    p3.plot(estm_time, x_err, pen=(255,0,0), name="Error X")
#    p3.setLabel('left', "x", units='m')
#    p3.setLabel('bottom', "time", units='s')
#    lr_1 = pg.LinearRegionItem([0,5])
#    #lr_1.setZValue(-0.01)
#    p3.addItem(lr_1)

#    p4 = win3.addPlot(title="Zoom on selected region")
#    p4.plot(estm_time, x_err, pen=(255,0,0), name="Error X")
#    def updatePlot():
#        p4.setXRange(*lr_1.getRegion(), padding=0)
#    def updateRegion():
#        lr_1.setRegion(p4.getViewBox().viewRange()[0])
#    lr_1.sigRegionChanged.connect(updatePlot)
#    p4.sigXRangeChanged.connect(updateRegion)
#    updatePlot()
#
#    win3.nextRow()
#
#    p5 = win3.addPlot(title="Error in y")
#    p5.plot(estm_time, y_err, pen=(255,0,0), name="Error Y")
#    p5.setLabel('left', "y", units='m')
#    p5.setLabel('bottom', "time", units='s')
#    lr_2 = pg.LinearRegionItem([0,5])
#    #lr.setZValue(-10)
#    p5.addItem(lr_2)
#
#    p6 = win3.addPlot(title="Zoom on selected region")
#    p6.plot(estm_time, y_err, pen=(255,0,0), name="Error Y")
#    def updatePlot():
#        p6.setXRange(*lr_2.getRegion(), padding=0)
#    def updateRegion():
#        lr_2.setRegion(p6.getViewBox().viewRange()[0])
#    lr_2.sigRegionChanged.connect(updatePlot)
#    p6.sigXRangeChanged.connect(updateRegion)
#    updatePlot()
#
#    win3.nextRow()
#
#    p7 = win3.addPlot(title="Error in theta")
#    p7.plot(estm_time, theta_err, pen=(255,0,0), name="Error theta")
#    p7.setLabel('left', "theta", units='rad')
#    p7.setLabel('bottom', "time", units='s')
#    lr_3 = pg.LinearRegionItem([5,10])
#    #lr.setZValue(-10)
#    p7.addItem(lr_3)
#
#    p8 = win3.addPlot(title="Zoom on selected region")
#    p8.plot(estm_time, theta_err, pen=(255,0,0), name="Error theta")
#    def updatePlot():
#        p8.setXRange(*lr_3.getRegion(), padding=0)
#    def updateRegion():
#        lr_3.setRegion(p8.getViewBox().viewRange()[0])
#    lr_3.sigRegionChanged.connect(updatePlot)
#    p8.sigXRangeChanged.connect(updateRegion)
#    updatePlot()





    #   Create the second window with paths and distances
    win2 = pg.GraphicsWindow(title="Trajectories, measurements and distances")
    win2.resize(1000,600)
    win2.setWindowTitle('Trajectories, measurements and distances')

    #   Enable antialiasing for prettier plots
    pg.setConfigOptions(antialias=True)

    #   Create first plot containing the trajectories of robot, odometry
    #   and estimator
    p1 = win2.addPlot(title="Trajectories")
    p1.addLegend()
    p1.plot(x_real, y_real, pen=pg.mkPen('r', width=4), name="Real path")
    p1.plot(x_odom, y_odom, pen=pg.mkPen('g', width=4), name="Odometry path")
    p1.plot(x_estm, y_estm, pen=pg.mkPen('b', width=4), name="Estimated path")
    p1.plot(sx, sy, pen=None, symbol='o')


    for line in lines_detected:
        p1.plot(line[0], line[1], pen=pg.mkPen('y', width=3, style=QtCore.Qt.DashLine))


    p1.setLabel('left', "Y Axis", units='m')
    p1.setLabel('bottom', "X Axis", units='m')
    #   Plot the lines in a 10x10 world as in rviz
    for a in range( int(5/xSpacing) ):
        p1.plot([a*xSpacing, a*xSpacing], [-5, 5], pen=(150, 150, 150))
        p1.plot([-a*xSpacing, -a*xSpacing], [-5, 5], pen=(150, 150, 150))

    for b in range( int(5/ySpacing) ):
        p1.plot([-5, 5], [b*ySpacing, b*ySpacing], pen=(150, 150, 150))
        p1.plot([-5, 5], [-b*ySpacing, -b*ySpacing], pen=(150, 150, 150))

    p1.showGrid(x=True, y=True)

    #   Create a second plot with the Mahalanobis distances
    p2 = win2.addPlot(title="Mahalanobis distances")
    p2.plot([time_dist[0], time_dist[-1]], [threshold, threshold], pen=(255,0,0), name="Threshold")
    p2.plot(time_dist, mh_dist, pen=None, symbol='o', name="Mahalanobis distance")
    p2.setLabel('left', "x", units='undimensional distances')
    p2.setLabel('bottom', "time", units='s')


    #   Create the first window with paths and distances
    win1 = pg.TableWidget(sortable=False)
    win1.show()
    win1.resize(320,650)
    win1.setWindowTitle('Table of Parameters')


    data = np.array([
        ('WORLD PARAMETERS',0.0),
        ('x_spacing',xSpacing),
        ('y_spacing',ySpacing),
        ('line_thickness',lineThickness),
        ('ROBOT PARAMETERS',0.0),
        ('Wheel radius',  wheelRadius),
        ('Track gauge', 2*frontAxle),
        ('Real initial position x', xInit),
        ('Real initial position y', yInit),
        ('Real initial position theta', thetaInit),
        ('ODOMETRY PARAMETERS',0.0),
        ('wheel_1_error',wheelRadiusError),
        ('track_gauge_error',trackGaugeError),
        ('encoders_resolution',encodersResolution),
        ('ESTIMATOR PARAMETERS',0.0),
        ('sigma_tuning',sigmaTuning),
        ('Threshold',   threshold),
        ('Estimated initial position x',x_estm[0]),
        ('Estimated initial position y',y_estm[0]),
        ('Estimated initial position theta', theta_estim[0])
        ], dtype=[('Parameter', object), ('Value', float)])


    win1.setData(data)




    QtGui.QApplication.instance().exec_()
