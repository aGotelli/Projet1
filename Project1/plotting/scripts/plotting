#!/usr/bin/env python

"""
 * \file plotting
 * \brief Plots the data storaged in a rosbag and in a yaml files with same name
 * \author Bianca Lento & Andrea Gotelli
 * \version 0.1
 * \date 19/06/2020
 *
 * \param[in]
 *
 * Subscribes to: <BR>
 *
 *
 * Publishes to: <BR>
 *
 *
 * Description
            This file takes the data from a rosbag and a yaml file with the same name
        and plots the results in some graph. The aim is to make clear the behaviour of
        the estimator throught various plots. The language that has been chosen is
        python as it is the best when dealing with data analisys.

            Moreover, the toolbox of PyQtGraph has been chose as it guarantees
        fluid but very accurate plots. It is not built-in in Ubuntu, so it needs to
        be installed following the proper tutorial (see the README file).

            In the beginning of this script, with the filename (and related path)
        passed as argument, the relevant data of the yaml file are loaded.
        Additionally, some ranged loops takes all the desired messages from the
        rosbag of interest. The choice was to define a specific loop for every
        topic of interest. One could say that it is possible to take different
        topic from a single loop. However, this single loop will be executed several
        times, one for each topic, so the two approach take the same amount of time.

            Once all the messages have been saved in the program, the motionless
        parts will be deleted, in order to focus the attention only in the results
        when the robot is moving.

            Once the data is prepared, the Qt Console is started and the plot
        are displayed.

 *
"""

# modules
# ROS stuff and multithreading
import rospy
import rosbag
import sys
import yaml
from pyqtgraph.Qt import QtGui, QtCore
import numpy as np
import pyqtgraph as pg
from tf.transformations import euler_from_quaternion




if __name__ == '__main__':

    rospy.init_node('plotting')

#################################~  COLLECTING DATA ~###################################

    #   Load from yaml file the parameters
    with file( sys.argv[1] + '.yaml' ) as setting:
        parameters = yaml.load( setting )

    #   Obatin world parameters
    xSpacing = parameters['sensor']['x_spacing']
    ySpacing = parameters['sensor']['y_spacing']
    lineThickness = parameters['sensor']['line_thickness']

     #   Obatin robot parameters
    wheelRadius = parameters['robot_2_0']['wheel_radius']
    frontAxle = parameters['robot_2_0']['a']
    wheelRadiusError = parameters['robot_2_0']['wheel_1_error']
    trackGaugeError = parameters['robot_2_0']['track_gauge_error']
    encodersResolution = parameters['robot_2_0']['encoders_resolution']
    xInit = parameters['robot_2_0']['x_init']
    yInit = parameters['robot_2_0']['y_init']
    thetaInit = parameters['robot_2_0']['theta_init']

    #   Obtain estimator setting
    sigmaTuning = parameters['estimator']['sigma_tuning']
    threshold  = parameters['estimator']['threshold']

    #   Open the required bag file
    bag = rosbag.Bag( sys.argv[1] + '.bag' )


    #   Obatin the real path that the robot has followed
    x_real = []
    y_real = []
    theta_real = []
    sim_time = []
    for topic, robot, t in bag.read_messages(topics=['/RobotPosture']):
        x_real.append( robot.position.x )
        y_real.append( robot.position.y )
        orientation_q = robot.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_real.append( yaw )
        sim_time.append( t.to_sec() )


    #   Obtain the path that the estimator has computed
    x_estm = []
    y_estm = []
    theta_estim = []
    cov_x = []
    cov_y = []
    cov_theta = []
    estm_time = []
    estm_time1 = []
    for topic, estm, t in bag.read_messages(topics=['/EstimatedPosture']):
        x_estm.append( estm.pose.position.x )
        y_estm.append( estm.pose.position.y )
        orientation_q = estm.pose.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion (orientation_list)
        theta_estim.append( yaw )
        cov_x.append( estm.covariance[6*0 + 0] )
        cov_y.append( estm.covariance[6*1 + 1] )
        cov_theta.append( estm.covariance[6*5 + 5] )
        estm_time.append( t.to_sec() )
        estm_time1.append( t.to_sec() )


    #   Obtain the error in the estimation
    x_err = []
    y_err = []
    theta_err = []
    time_err = []
    for topic, error, t in bag.read_messages(topics=['/EstimationError']):
        x_err.append( error.position.x )
        y_err.append( error.position.y )
        orientation_q = error.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        (roll, pitch, yaw) = euler_from_quaternion( orientation_list )
        theta_err.append( yaw )
        time_err.append( t.to_sec() )


    #   Obtain an estimation of the path odometry based
    x_odom = []
    y_odom = []
    for topic, odom, t in bag.read_messages(topics=['/RobotOdometry']):
        x_odom.append( odom.pose.pose.position.x )
        y_odom.append( odom.pose.pose.position.y )


    #   Obtain information about the measurements
    class Measurement:
        def __init__(self, time, mh_dist, status, x, y):
            self.time = float(time)
            self.mh_dist = float(mh_dist)
            self.accepted = bool( status )
            self.x = float( x )
            self.y = float( y )

    processedMeasurements = []
    acp_meas_time = []
    rjt_meas_time = []
    acp_mh_dist = []
    rjt_mh_dist = []
    acp_x_meas = []
    acp_y_meas = []
    rjt_x_meas = []
    rjt_y_meas = []
    accepted = []
    lines_detected = []
    prev_h = -1000
    prev_v = -1000
    for topic, meas, t in bag.read_messages(topics=['/Measurements']):

        processedMeasurements.append( Measurement(  t.to_sec(),
                                                    meas.distance,
                                                    meas.accepted,
                                                    meas.pose.position.x,
                                                    meas.pose.position.y) )

        if meas.accepted:

            if meas.line_type == 'HORIZONTAL':

                if meas.line_index != prev_h:
                    prev_v = -1000
                    pos = [[meas.pose.position.x - xSpacing/2, meas.pose.position.x + xSpacing/2], [meas.line_index, meas.line_index]]
                    lines_detected.append(pos)
                    prev_h = meas.line_index
            else:
                if meas.line_index != prev_v:
                    prev_h = -1000
                    pos = [[meas.line_index, meas.line_index], [meas.pose.position.y - ySpacing/2, meas.pose.position.y + ySpacing/2]]
                    lines_detected.append(pos)
                    prev_v = meas.line_index

            acp_meas_time.append( t.to_sec() )
            acp_mh_dist.append( meas.distance )
            acp_x_meas.append( meas.pose.position.x )
            acp_y_meas.append( meas.pose.position.y )

        else:
            rjt_meas_time.append( t.to_sec() )
            rjt_mh_dist.append( meas.distance )
            rjt_x_meas.append( meas.pose.position.x )
            rjt_y_meas.append( meas.pose.position.y )


    #   Obtain the Mahalanobis distances
#    mh_dist = []
#    time_dist = []
#    for topic, dist, t in bag.read_messages(topics=['/Mahalanobis']):
#        mh_dist.append( dist.data )
#        time_dist.append( t.to_sec() )


    #   Obtain the input velocities
    linear = []
    angular = []
    for topic, vel, t in bag.read_messages(topics=['/Velocities']):
        linear.append( vel.linear.x )
        angular.append( vel.angular.z )


    #   No need of the bag file anymore
    bag.close()


#################################~  PREPOCESS DATA ~###################################

    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_real ) )
    i = 0
    while (i<nbSamples) and (x_real[i]-x_real[i+1]==0) and (y_real[i]-y_real[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1
    while (i> -nbSamples) and (x_real[i]-x_real[i-1]==0) and (y_real[i]-y_real[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts
    del x_real[0: startIndex]
    del y_real[0: startIndex]
    del theta_real[0: startIndex]
    del sim_time[0: startIndex]

    del x_real[stopIndex: -1]
    del y_real[stopIndex: -1]
    del theta_real[stopIndex: -1]
    del sim_time[stopIndex: -1]



    #   Normalize the seconds counters
    sim_time = np.asarray(sim_time)
    sim_time = sim_time - sim_time[0]



    #   Skip motionless initial part if any
    nbSamples = len( np.asarray( x_estm ) ) -1
    i = 0
    while (i<nbSamples) and (x_estm[i]-x_estm[i+1]==0) and (y_estm[i]-y_estm[i+1]==0):
        i = i+1

    startIndex = i
    #   Skip motionless final part if any
    i = -1

    while (i> -nbSamples) and (x_estm[i]-x_estm[i-1]==0) and (y_estm[i]-y_estm[i-1]==0):
        i = i-1

    stopIndex = i

    #   Extract relevant data by removing motionless parts
    del x_estm[0: startIndex]
    del y_estm[0: startIndex]
    del theta_estim[0: startIndex]
#    del processedMeasurements[0: startIndex]
#    del meas_time[0: startIndex]
#    del mh_dist[0: startIndex]
#    del x_meas[0: startIndex]
#    del y_meas[0: startIndex]
#    del cov_x[0: startIndex]
#    del cov_y[0: startIndex]
#    del cov_theta[0: startIndex]
#    del x_err[0: startIndex]
#    del y_err[0: startIndex]
#    del theta_err[0: startIndex]
    del estm_time[0: startIndex]
    del linear[0: startIndex]
    del angular[0: startIndex]


    del x_estm[stopIndex: -1]
    del y_estm[stopIndex: -1]
    del theta_estim[stopIndex: -1]
#    del processedMeasurements[stopIndex: -1]
#    del meas_time[stopIndex: -1]
#    del mh_dist[stopIndex: -1]
#    del x_meas[stopIndex: -1]
#    del y_meas[stopIndex: -1]
#    del cov_x[stopIndex: -1]
#    del cov_y[stopIndex: -1]
#    del cov_theta[stopIndex: -1]
#    del x_err[stopIndex: -1]
#    del y_err[stopIndex: -1]
#    del theta_err[stopIndex: -1]
    del estm_time[stopIndex: -1]
    del linear[stopIndex: -1]
    del angular[stopIndex: -1]

    #   Normalize the seconds counters
#    time_dist = np.asarray(time_dist)
#    time_dist = time_dist - time_dist[0]

    estm_time = np.asarray(estm_time)
    estm_time = estm_time - estm_time[0]

    estm_time1 = np.asarray(estm_time1)
    estm_time1 = estm_time1 - estm_time1[0]

    acp_meas_time = np.asarray(acp_meas_time)
    acp_meas_time = acp_meas_time - acp_meas_time[0]


    time_err = np.asarray(time_err)
    time_err = time_err - time_err[0]

    if(len(rjt_meas_time) > 0):
        rjt_meas_time = np.asarray(rjt_meas_time)
        rjt_meas_time = rjt_meas_time - rjt_meas_time[0]

#    time_mes = np.asarray(time_mes)
#    time_mes = time_mes - time_mes[0]



    initial = processedMeasurements[0].time

    for meas in processedMeasurements:
        meas.time = meas.time - initial


#################################~  PLOTTING DATA ~###################################



    #   Start the console
    app = QtGui.QApplication([])


    #  Create the fifth window with velocities

#    win5 = pg.GraphicsWindow(title="Velocities")
#    win5.resize(1000,600)
#    win5.setWindowTitle('Velocities')
#
#    p12 = win5.addPlot(title="Linear Velocity")
#    p12.plot( estm_time, linear, pen=(255,0,0), name="linear vel")
#    p12.setLabel('left', "linear vel")
#    p12.setLabel('bottom', "time", units='s')
#
#    win5.nextRow()
#
#    p13 = win5.addPlot(title="Angular Velocity")
#    p13.plot( estm_time, angular, pen=(255,0,0), name="angular vel")
#    p13.setLabel('left', "angular vel")
#    p13.setLabel('bottom', "time", units='s')




    #  Create the fourth window with standard deviations
    win4 = pg.GraphicsWindow(title="Standard deviations of x, y and theta")
    win4.resize(1000,600)
    win4.setWindowTitle('Standard deviations of x, y and theta')

    p9 = win4.addPlot(title="Standard deviation of x")
    p9.plot(estm_time1, np.sqrt(cov_x), pen=(255,0,0), name="sigma X")
    p9.setLabel('left', "sigma x", units='m')
    p9.setLabel('bottom', "time", units='s')

    win4.nextRow()

    p10 = win4.addPlot(title="Standard deviation of y")
    p10.plot(estm_time1, np.sqrt(cov_y), pen=(255,0,0), name="sigma Y")
    p10.setLabel('left', "sigma y", units='m')
    p10.setLabel('bottom', "time", units='s')

    win4.nextRow()

    p11 = win4.addPlot(title="Standard deviation of theta")
    p11.plot(estm_time1, np.sqrt(cov_theta)*180/np.pi, pen=(255,0,0), name="sigma Theta")
    p11.setLabel('left', "sigma theta", units='')
    p11.setLabel('bottom', "time", units='s')




    #   Create the third window with the errors
    win3 = pg.GraphicsWindow(title="Errors along x, y and in heading")
    win3.resize(1000,600)
    win3.setWindowTitle('Errors along x, y and in heading')


    p3 = win3.addPlot(title="Error in x")
    p3.addLegend()
    p3.plot(estm_time1,  3*np.sqrt(cov_x), pen=(255,0,0), name="+-3 sigmaX")
    p3.plot(time_err, x_err, pen=(0,0,255), name="Error X")
    p3.plot(estm_time1,  -3*np.sqrt(cov_x), pen=(255,0,0))
    p3.setLabel('left', "x", units='m')
    p3.setLabel('bottom', "time", units='s')
    lr_1 = pg.LinearRegionItem([0,2])
    #lr_1.setZValue(-0.01)
    p3.addItem(lr_1)

    p4 = win3.addPlot(title="Zoom on selected region")
    p4.plot(estm_time1,  3*np.sqrt(cov_x), pen=(255,0,0), name="+-3 sigmaX")
    p4.plot(time_err, x_err, pen=(0,0,255), name="Error X")
    p4.plot(estm_time1,  -3*np.sqrt(cov_x), pen=(255,0,0))
    def updatePlot():
        p4.setXRange(*lr_1.getRegion(), padding=0)
    def updateRegion():
        lr_1.setRegion(p4.getViewBox().viewRange()[0])
    lr_1.sigRegionChanged.connect(updatePlot)
    p4.sigXRangeChanged.connect(updateRegion)
    updatePlot()

    win3.nextRow()

    p5 = win3.addPlot(title="Error in y")
    p5.addLegend()
    p5.plot(estm_time1,  3*np.sqrt(cov_y), pen=(255,0,0), name="+-3 sigmaY")
    p5.plot(time_err, y_err, pen=(0,0,255), name="Error Y")
    p5.plot(estm_time1,  -3*np.sqrt(cov_y), pen=(255,0,0))
    p5.setLabel('left', "y", units='m')
    p5.setLabel('bottom', "time", units='s')
    lr_2 = pg.LinearRegionItem([0,2])
    #lr.setZValue(-10)
    p5.addItem(lr_2)

    p6 = win3.addPlot(title="Zoom on selected region")
    p6.plot(estm_time1,  3*np.sqrt(cov_y), pen=(255,0,0), name="+-3 sigmaY")
    p6.plot(time_err, y_err, pen=(0,0,255), name="Error Y")
    p6.plot(estm_time1,  -3*np.sqrt(cov_y), pen=(255,0,0))
    def updatePlot():
        p6.setXRange(*lr_2.getRegion(), padding=0)
    def updateRegion():
        lr_2.setRegion(p6.getViewBox().viewRange()[0])
    lr_2.sigRegionChanged.connect(updatePlot)
    p6.sigXRangeChanged.connect(updateRegion)
    updatePlot()

    win3.nextRow()

    p7 = win3.addPlot(title="Error in theta")
    p7.addLegend()
    p7.plot(estm_time1,  (3*180/np.pi)*np.sqrt(cov_theta), pen=(255,0,0), name="+-3 sigmaTheta")
    p7.plot(time_err, theta_err, pen=(0,0,255), name="Error theta")
    p7.plot(estm_time1,  -(3*180/np.pi)*np.sqrt(cov_theta), pen=(255,0,0))
    p7.setLabel('left', "theta", units='rad')
    p7.setLabel('bottom', "time", units='s')
    lr_3 = pg.LinearRegionItem([0,2])
    #lr.setZValue(-10)
    p7.addItem(lr_3)

    p8 = win3.addPlot(title="Zoom on selected region")
    p8.plot(estm_time1,  (3*180/np.pi)*np.sqrt(cov_theta), pen=(255,0,0), name="+-3 sigmaTheta")
    p8.plot(time_err, theta_err, pen=(0,0,255), name="Error theta")
    p8.plot(estm_time1,  -(3*180/np.pi)*np.sqrt(cov_theta), pen=(255,0,0))
    def updatePlot():
        p8.setXRange(*lr_3.getRegion(), padding=0)
    def updateRegion():
        lr_3.setRegion(p8.getViewBox().viewRange()[0])
    lr_3.sigRegionChanged.connect(updatePlot)
    p8.sigXRangeChanged.connect(updateRegion)
    updatePlot()


    #   Create the second window with paths and distances
    win2 = pg.GraphicsWindow(title="Trajectories, measurements and distances")
    win2.resize(1000,600)
    win2.setWindowTitle('Trajectories, measurements and distances')

    #   Enable antialiasing for prettier plots
    pg.setConfigOptions(antialias=True)

    #   Create first plot containing the trajectories of robot, odometry
    #   and estimator
    p1 = win2.addPlot(title="Trajectories")
    p1.addLegend()

    p1.plot(x_real, y_real, pen=pg.mkPen('g', width=4), name="Real path")
    p1.plot(x_odom, y_odom, pen=pg.mkPen('r', width=4), name="Odometry path")
    p1.plot(x_estm, y_estm, pen=pg.mkPen('b', width=4), name="Estimated path")



    for measurement in processedMeasurements:
        if measurement.accepted == True:
            p1.plot([measurement.x, measurement.x], [measurement.y, measurement.y], pen=None, symbolBrush=(0.0, 0.0, 255), symbol='o')
        else:
            p1.plot([measurement.x, measurement.x], [measurement.y, measurement.y], pen=None, symbolBrush=(255, 0.0, 0.0), symbol='o', symbolSize=6)




    l = lines_detected[0]
    p1.plot(l[0], l[1], pen=pg.mkPen('y', width=3, style=QtCore.Qt.DashLine), name="Estimated line")

    for line in lines_detected:
        p1.plot(line[0], line[1], pen=pg.mkPen('y', width=3, style=QtCore.Qt.DashLine))


    p1.setLabel('left', "Y Axis", units='m')
    p1.setLabel('bottom', "X Axis", units='m')
    #   Plot the lines in a 10x10 world as in rviz
    for a in range( int(5/xSpacing) ):
        p1.plot([a*xSpacing, a*xSpacing], [-5, 5], pen=(150, 150, 150))
        p1.plot([-a*xSpacing, -a*xSpacing], [-5, 5], pen=(150, 150, 150))

    for b in range( int(5/ySpacing) ):
        p1.plot([-5, 5], [b*ySpacing, b*ySpacing], pen=(150, 150, 150))
        p1.plot([-5, 5], [-b*ySpacing, -b*ySpacing], pen=(150, 150, 150))

    p1.showGrid(x=True, y=True)

    #   Create a second plot with the Mahalanobis distances
    p2 = win2.addPlot(title="Mahalanobis distances")
    p2.setLogMode(False, True)
    p2.plot([processedMeasurements[0].time , processedMeasurements[-1].time], [threshold, threshold], pen=pg.mkPen('r', width=2), name="Threshold")

    p2.setLabel('left', "x", units='undimensional distances')
    p2.setLabel('bottom', "time", units='s')


    for measurement in processedMeasurements:
        if measurement.accepted == True:
            p2.plot([measurement.time, measurement.time], [measurement.mh_dist, measurement.mh_dist], pen=None, symbolBrush=(0.0, 0.0, 255), symbol='o')
        else:
            p2.plot([measurement.time, measurement.time], [measurement.mh_dist, measurement.mh_dist], pen=None, symbolBrush=(255, 0.0, 0.0), symbol='o')



    #   Create the first window with paths and distances
    win1 = pg.TableWidget(sortable=False)
    win1.show()
    win1.resize(430,650)
    win1.setWindowTitle('Table of Parameters')


    data = np.array([
        ('WORLD PARAMETERS',        0.0,                        ""),
        ('x_spacing',               xSpacing,                   "[m]"),
        ('y_spacing',               ySpacing,                   "[m]"),
        ('line_thickness',          lineThickness,              "[m]"),
        ('ROBOT PARAMETERS',        0.0,                        ""),
        ('Wheel radius',            wheelRadius,                "[m]"),
        ('Track gauge',             2*frontAxle,                "[m]"),
        ('Initial position x',      xInit,                      "[m]"),
        ('Initial position y',      yInit,                      "[m]"),
        ('Initial position theta',  thetaInit,                  "[grad]"),
        ('ODOMETRY PARAMETERS',     0.0,                        ""),
        ('wheel_1_error',           (wheelRadiusError-1)*100,   "[%]"),
        ('track_gauge_error',       (trackGaugeError-1)*100,    "[%]"),
        ('encoders_resolution',     encodersResolution,         "[dots/revolution]"),
        ('ESTIMATOR PARAMETERS',    0.0,                        ""),
        ('sigma_tuning',            sigmaTuning,                ""),
        ('Threshold',               threshold,                  ""),
        ('Initial position x',      x_estm[0],                  "[m]"),
        ('Initial position y',      y_estm[0],                  "[m]"),
        ('Initial position theta',  theta_estim[0]*180/np.pi,   "[grad]")
        ], dtype=[('Parameter', object), ('Value', float), ('Units', object)])


    win1.setData(data)




    QtGui.QApplication.instance().exec_()
